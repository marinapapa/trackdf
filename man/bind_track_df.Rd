% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr.R
\name{bind_track_df}
\alias{bind_track_df}
\alias{rbind.track_df}
\title{Bind Multiple Track Tables by Row}
\usage{
bind_track_df(..., .id = NULL)

\method{rbind}{track_df}(...)
}
\arguments{
\item{...}{Track tables to combine.

 Each argument can either be a track table, a list that could be track table,
 or a list of track table.
 Columns are matched by name, and any missing columns will be filled with NA.}

\item{.id}{Track table identifier.

 When .id is supplied, a new column of identifiers is created to link each
 row to its original data frame. The labels are taken from the named
 arguments to bind_rows(). When a list of data frames is supplied, the labels
 are taken from the names of the list. If no names are found a numeric
 sequence is used instead.}
}
\value{
A track table.
}
\description{
\code{bind_track_df} and \code{rbind.track_df} are modified
 versions of \code{\link[dplyr:bind_rows]{dplyr::bind_rows}} and
 \code{\link[base:rbind]{base::rbind}} respectively, that work with track
 tables. In particular, they make sure that you cannot bind together two
 tables with different projections and, in the case of \code{rbind.track_df},
 that the projection attribute is inherited by the resulting track table
 (\code{\link[dplyr:bind_rows]{dplyr::bind_rows}} strips it otherwise).
}
\note{
\code{\link[dplyr:bind_rows]{dplyr::bind_rows}} cannot be converted to
 a S3 generic and therefore cannot implement convenient dispatching based on
 the class of the tables it is provided with. As a consequence, it is not
 possible at the moment to provide specific implementations of \code{bind_row}
 for track tables.
}
\examples{
# TODO

}
\author{
Simon Garnier, \email{garnier@njit.edu}
}
